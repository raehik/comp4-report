% vim: spell
\section{Design}
\subsection{System overview}
\subsubsection{Software choices}

The first decision I have is on programming language, which will determine which
toolkits and packages I can use. Since I'm developing a desktop program using a
Linux-based OS, I decided on \textbf{C++} over Java or C\#, because from
experience I've found developing Java on Linux is troublesome, and C\#/.NET is a
Windows-based framework. C++ gives me good flexibility and was made for
object-oriented projects.

In my proposed system, data must be stored between program sessions. The main
database options available to me are:

\begin{itemize}
    \item A plain text file which is loaded into memory every time data needs to
        be accessed (unreliable \& requires further testing, easier to code).
    \item A SQLite database (local, simple to set up, highly tested \&
          reliable).
    \item A MySQL database (remote, requires Internet access, needs
          adminstrating).
\end{itemize}

I will be using SQLite for a local storage database, since it provides reliable
and fast data storage and searching, plus stores its database as a file on the
host computer so can be used offline. If I was using an online solution, I would
use MySQL instead, which provides many more features for efficient queries.

For the user interface, I have only a couple of viable options:

\begin{itemize}
    \item Qt, a C++ framework which provides a GUI framework strongly
          interlinked with Q* utility classes (e.g. QDate)
    \item GTK+, a C/C++ GUI toolkit, providing very similar graphical elements
          but fewer 'extra' features
\end{itemize}

I decided on Qt because it was written in and for C++, and I wouldn't have to
implement so many of my own utility classes for the graphical parts. It also
makes writing cross-platform software easier.


\boxref{2.2-modular}
\subsubsection{System modularity}

I am approaching the design of the system modularly, i.e. as much of the system
as possible will be \textit{pluggable}. Where required, classes and modules will
be required to inherit from a base class or module, or need to expose certain
functions, as a sort of API or 'contract'. For example, the class for handling
data storage and retrieval could use any generic \textbf{database helper}
object, and it would assume the class knows how to handle certain function
calls, and what return types it expects. In this way, a handler for a different
database could be written with minimal code duplication, which would be useful
if I need/want to change database systems (e.g. to CSV). This design also has
the useful implication of making exporting data into different formats easier (a
potential feature to implement later).

As much as possible, the data classes will not depend on specific features of my
chosen GUI framework. Because I'm using Qt there will be some overlap to
minimise code duplication and unneeded extra work, but I plan only to use Qt
features for things which can easily be swapped out for more abstract classes
later.


\boxref{2.4-records}
\subsection{Database records}

The database for my system will hold two types of records: \textbf{to-dos} and
\textbf{appointments}. Each record has different fields. For each table, field
types are shown next to the field name in brackets for the first row. Each
following row is an example valid record.


\subsubsection{To-do}

\begin{table}[H]
    \centering
    \begin{tabulary}{\linewidth}{|L|L|L|} \hline
            \textbf{ID (integer)} &
            \textbf{Text (string)} &
            \textbf{Completed? (Boolean)} \\ \hline
        1 & Order The \TeX Book                   & false \R
        2 & Buy some milk                         & true  \R
        3 & Check 'characters' allowed in a todo  & true  \R
    \end{tabulary}
    \caption{Example to-do records.}
    \label{tbl:todo-rec}
\end{table}

To-do IDs increment starting from 1. \texttt{Text} can be any string. The
\texttt{Completed?} field defines whether a to-do is 'finished' or not. A
completed to-do will show up at the bottom of the full to-do list and will
be clearly indicated as finished.

All the fields in a to-do are \textbf{required}.


\subsubsection{Appointment}

\begin{table}[H]
    \centering
    \begin{tabulary}{\linewidth}{|L|L|L|L|L|L|} \hline
            \textbf{ID (int.)} &
            \textbf{Title (str.)} &
            \textbf{Date (int.)} &
            \textbf{Description (str.)} &
            \textbf{Time (int.)} &
            \textbf{Location (str.)} \\ \hline
        1 & Work meeting & 2457431 &
            Amy \& Bob presenting their research in big data &
            58800 & Meeting room \R
    \end{tabulary}
    \caption{Example appointment records.}
    \label{tbl:todo-appt}
\end{table}

ID increments from 1. In an appointment record, the \textbf{ID, title, date and
time} fields are required. The location and description are fields for extra
information, which will make it easier to visually search through appointments
for certain events.


\boxref{2.1-overall}
\subsection{IPSO table}

\addfigure
    {ipso}
    {An IPSO table for the planned software.}
    {fig:ipso}


\boxref{2.5-validation}
\subsection{Input validation}

A SQLite database can store any string of characters -- however, if a
user escapes their input in a certain way (on purpose or not), it could
potentially break the record insert statement, which could cause no appointment
to be added. It is not hard for a malicious user to create a query which would
end the insert statement early, then run another statement to e.g. delete all
records in a database.

A programmer can prevent such attacks (known as \textbf{SQL injection
attacks}) by parameterising user input rather than inserting user input as
substrings into a main query string. As long as this is implemented, the user
can input any string and it would be valid for a new record.

The other input validation I need to do is to ensure that all strings are
displayed correctly. Some of Qt's classes will automatically display strings as
formatted HTML, meaning users can create unexpected effects and potential layout
problems if they insert \texttt{<h1>} or other such tags. It is possible to
disable this so that strings are displayed exactly as they were entered.

To-do and appointment records both have some required fields, so when the user
is entering data for a new record those fields should be checked to make sure
they are not empty.


\boxref{2.6-database-design}
\subsection{Database design}

Qt provides a multitude of 'safe' file paths to use for storing user data in,
which (importantly) are guaranteed to work across multiple operating systems. My
program only uses one file, which is the database file.

The database is simple and holds two types of records: 'appointments' and
'to-dos' in their respective databases. (See the Database Records section for
more.)


\boxref{2.7-sql}
\subsection{Sample SQL queries}

In my program, I will have a layer on abstraction on top of SQL, so GUI windows
will not be making SQL queries. Instead they will call a database handler which
in turn calls its specific database helper, which will translate the function
call and parameters into a query for its database, execute it, then return a
result or a code indicating success or failure. I only plan to implement one
database helper for SQLite, but this setup allows better separation of concerns
between GUI elements and the database.

My SQLite database helper will be making many different parameterised queries.
Appointment and to-do records must be INSERTed, UPDATEd, SELECTed and DELETEd.
The SELECT statements will be especially varied, since I'm using two different
views for appointments. Furthermore, to create tables for a new database file, I
need to run EXEC statements.

An example INSERT statement for an appointment would be:

\begin{minted}[breaklines,xleftmargin=15pt]{text}
\end{minted}



\boxref{2.9-data-algos}
\subsection{Data transformation algorithms}

Dates and times are tricky to handle. If stored in string format (e.g.
\texttt{2016-01-02 15:30}) it becomes overly complex to compare two records and
find which is before the other. Thus I need to represent arbitrary dates and
times as numbers.


\subsubsection{Time}

This is easy for a time: storing the number of minutes (or seconds) since 00:00
would suffice, and make comparisons easy and also less data would be stored than
if a string was used. An example manual implementation using seconds
since midnight follows:

\begin{minted}[breaklines,frame=lines,xleftmargin=15pt]{text}
time_input = "16:20:24"
hours, minutes, seconds = time_split(time_input)
return seconds + (minutes * 60) + (hours * 60 * 60) // = 58824
\end{minted}


\subsubsection{Date}

For a specific day, a common count used is the Julian day, which is an integer
indicating the number of days since January 1, 4713 BC (the start of the Julian
Period). This can represent every and any day a user would need, and again uses
fewer bytes than a string representation. All the following divisions are
\textbf{floored operations} \cite{wiki-julian}:

\begin{minted}[breaklines,frame=lines,xleftmargin=15pt]{text}
day_input = "2010-11-13"
year, month, day = date_split(day_input)
julian_day = (1461 * (year + 4800 + (month - 14)/12))/4 + (367 * (month - 2 - 12 * ((month - 14)/12)))/12 - (3 * ((year + 4900 + (month - 14)/12)/100))/4 + day - 32075
\end{minted}


\subsection{TODO sort}

\newcommand{\classitem}[1]{\item \textbf{#1}}

\begin{itemize}
    \classitem{DBHelper}: Interface for classes which interface with a specific
    database system (e.g. SQLite, MySQL).
    \classitem{SQLiteHelper}: DBHelper for manipulating a SQLite database
    (inserting/selecting data, executing commands)and inserting/selecting data.
    \classitem{DataHandler}: Handles retrieving data and updating the database.
    Uses a class derived from DBHelper to interface with the actual database.
    \classitem{PDFExporter}
\end{itemize}

\begin{itemize}
    \classitem{GuiMainWindow}: The 'master' GUI window, the main one that the
        user interacts with.
    \classitem{DataEntrySubmitWindow}: Interface for simple dialog windows
        which take user input and use it somehow (e.g. add to a database or make
        a database search)
    \classitem{CalendarViewWindow}: Interface for a calendar view in a separate
        window. Should have an option to print the view.
    \classitem{TodoWidget}: A to-do widget for the main window.
    \classitem{RecentApptsWidget}: A recent appointments widget for the main
    window.
    \classitem{MonthViewWidget}:
\end{itemize}


\subsubsection{DataHandler}

Reasoning for this is that it means I can:

\begin{itemize}
    \item Move between databases without changing unrelated code
    \item Easily implement caching if it turns out to be required
\end{itemize}

Separating the generic 'data movement interface' from the specific database
protocol used means that code which handles data does \textit{not} need to know
about the database being used.

\begin{itemize}
    \item \verb+insert_appts(vector<Appointment>)+
    \item \verb+select_appts(string title, string description)+
\end{itemize}
